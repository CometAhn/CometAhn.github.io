var tipuesearch = {"pages": [{
    "title": "자바스크립트 기본 개요",
    "text": "자바스크립트 기본 개요 자바스크립트는 웹 브라우저에서 동작하는 스크립트 언어이다. 하지만 처음부터 그렇게 웹 개발자에게 친숙한 언어는 아니었다. 초창기 자바스크립트는 웹 페이지 제작에 있어서 보조적인 기능을 수행하기 위한 용도로써 사용했다. 대부분의 로직은 주로 웹 서버에서 실행되었고, 클라이언트인 웹 브라우저에서는 서버로부터 받은 HTML과 CSS, 데이터로 렌더링을 해주는 수준이었다. 이 시절에 자바스크립트는 그다지 중요한 역할을 담당하지 못했다. 다만 소수의 자바스크립트 프로그래머들에 의해 여러 가지 연구가 이루어지고, protoyupe.js와 같은 주요 라이브러리들이 개발된다. 그리고 웹이 더욱 발전하면서, 웹 아키텍처에도 여러 가지 크고 작은 변화가 일어났다. 특히, 과거에 서버에서 담당하던 역할들이 상당 부분 웹 브라우저로 이동하였고, 자바스크립트는 이 변화의 중심에 서게 된다. 게다가 jQuery의 등장으로 보다 쉽게 DOMDocument Object Model을 핸들링하게 되면서 많은 발전을 이루었다. 자바스크립트 활용 범위 웹 개발 서버 개발 애플리케이션 개발 자바스크립트의 핵심 개념 객체 자바스크립트의 거의 모든 것은 객체이다. 여기서 ‘거의’라는 표현을 쓰는 이유는 몇 가지가 제외되기 때문이다. 바로 기본 데이터 타입인 boolean, number, string이다. 그리고 특별한 값인 null, undefined도 해당된다. 이를 제외한 나머지는 모두 객체이다. 앞의 세 가지 기본 데이터 타입은 모두 객체처럼 다룰 수도 있다. 그렇기 때문에 자바스크립트는 null과 undefined를 제외한 모든 것을 객체로 다룰 수 있다. 함수 자바스크립트에서는 함수도 객체로 취급한다. 일반적인 객체보다 조금 더 많은 기능이 있는 객체라고 할 수 있다. 하지만 이렇게 단순히 표현하기엔 자바스크립트에서 함수는 상당히 중요하다. 이는 함수가 일급 객체First class object로 다뤄지기 때문이다. 프로토타입 모든 객체는 숨겨진 링크Link인 프로토타입Prototype을 가진다. 이 링크는 해당 객체를 생헌한 생성자의 프로토타입 객체를 가리킨다. 이 링크를 ECMAScript에서는 [[Prototype]]이라고 표현한다. 이 링크로 자바스크립트는 훨ㅆ씬 더 다양하게 자신만의 자료 구조를 작성할 수 있다. 실행 컨텍스트와 클로저 자바스크립트는 자신만의 독특한 과정으로 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다. 이 실행 컨텍스트는 자신만의 유효 범위Scope를 갖는데, 이 과정에서 클로저를 구현할 수 있다. 이것은 자바스크립트를 제대로 이해하기 위한 핵심 개념이다. 자바스크립트와 객체지향 프로그래밍 자바스크립트는 클래스를 지원하지 않지만 객체지향 프로그래밍이 가능하다. 프로토타ㅣㅂ 체인과 클로저로 객체지향 프로그래밍에서 제시하는 상속, 캡슐화, 정보 은닉 등의 개념을 소화할 수 있다. 실제로 GOF의 디자인 패턴을 자바스크립트로 구현한 코드들이 많이 공개되어 있고, 많은 개발자의 관심을 받고 있다. 자바스크립트와 함수형 프로그래밍 자바스크립트는 함수형 프로그래밍이 가능하다. 함수형 프로그래밍은 높은 수준의 모듈화를 가능케 하는 매우 효율적인 프로그래밍 방법이다. 자바스크립트는 주요 특성인 일급 객체로서의 함수 특성과 클로저를 활용하여 이를 가능케 한다. 하지만 이 때문에, 가독성을 떨어뜨리기도 한다. 과도하게 클로저가 사용되었거나, 함수형 프로그래밍 기법으로 구현된 코드는 제 3자가 해석하기가 상당히 난해하다. ###자바스크립트의 단점 자바스크립트는 굉장히 유연한 언어이고 뛰어난 표현력을 가지고 있다. 하지만 이러한 특성 때문에 종종 디버깅에 어려움을 겪기도 한다. 특히, 느슨한 타입 체크는 개발자에게 타입 체크에 대한 자유를 주지만, 컴파일 타임에서 잡지 못하는 오류는 고스란히 런타임 오류로 발견된다. 또, 자바스크립트를 둘러싼 중요한 논란 중에 하나가 전역 객체의 존재이다. 최상위 레벨의 객체들은 모두 전역 객체 안에 위치하는데, 이는 이름 추돌의 위험성이 있다. 프로그래머는 이 부분에 대해 신경 쓰는 것을 게을리 하면 안 된다. 그 동안 여러 자바스크립트 개발자가 자바스크립트의 언어 명세서인 ECMAScript를 비판해왔다. 1999년에 채택된 ECMAScript 3 버전은 ㅏㅇ당히 모호한 설명이 많다고 한다. 결국 이 모호한 명세서가 자바스크립트 엔진을 구현하는 데 있어서 약간의 차이를 가져왔고, 현재 자바스크립트 프로그래머에게는 브라우저 독립적인 코드를 구현해내는 것이 큰 숙제가 되었다. 다행히 2009년에 ECMAScrript 5 버전이 승인 되었고, 현재는 더 발전된 차기 버전에 대한 논의가 활발하게 이루어지고 있다. 본 게시글은 한빛미디어의 인사이드 자바스크립트(송형주, 고현준)라는 책을 공부하며 작성한 글입니다.",
    "tags": "javascript JavaScript",
    "url": "/jekyll-theme-yat/javascript/2022/12/25/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EC%9A%94.html"
  },{
    "title": "데이터셋 row 추가",
    "text": "Design 콤보박스 cboNumber, CboAlpha 생성. 데이터셋 dsNumber, dsAlpha 생성. 각각의 데이터셋에 0번째 컬럼 생성. 각각의 콤보박스에 데이터셋 매핑. Script this.jsPR_onload = function(obj:nexacro.Form,e:nexacro.LoadEventInfo) { // 1 ~ 99 데이터가 있는 데이터셋 생성 for(var i = 0; i&lt;99;i++){ //i번째 row 생성 this.dsNumber.addRow(i); //i번째째 로우, 0번째 컬럼에 i+1 입력. this.dsNumber.setColumn(i, 0, i+1); } // A ~ Z 데이터가 있는 데이터셋 생성 for(var j = 0; j &lt;26; j++){ //j번째 row 생성 this.dsAlpha.addRow(j); //j번째째 로우, 0번째 컬럼에 String.fromCharCode(65+j) 입력. this.dsAlpha.setColumn(j, 0, String.fromCharCode(65 + j)); } }; 결과",
    "tags": "nexacro javascript",
    "url": "/jekyll-theme-yat/nexacro/2022/12/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%85%8B-row-%EC%B6%94%EA%B0%80.html"
  },{
    "title": "ajax로 아이디 중복 검사하기",
    "text": "1. Ajax란? Ajax(Asynchronous JavaScript and Xml)은 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법이다. Ajax는 웹 페이지 전체를 다시 리로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있고, 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시할 수 있다. 이 때 서버와 여러 데이터를 주고 받을 수 있다. 데이터는 JSON, XML(deault), HTMl, Text 등의 방법으로 전송된다. 2. Ajax의 장단점 장점 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다. 웹 페이지가 로드된 후 서버로 데이터 요청을 보내거나 받을 수 있다. 다양한 UI(동적 페이지) 구현이 가능하다. 단점 페이지 이동이 없기 때문에 히스토리 관리가 안된다. 반복적인 데이터를 요청하면 느려지거나 작동하지 않게 된다. 페이지 이동이 없다는 것은 보안상의 문제도 발생할 수 있다는 것이다. 3. 프로젝트에 적용 addMember.jsp &lt;script&gt; $('#id-check').on(\"click\", (e) =&gt; { const id = $('#id').val(); e.preventDefault() console.log('btn click') if(id.length === 0 || id === null) return alert(\"아이디를 입력하세요\") $.ajax({ type:'post', async:false, url:'http://localhost/Lib/idcheck', dataType:'text', data:{id:id}, success: function(data, textStatus) { const jsonInfo = JSON.parse(data); if(jsonInfo.used === 'no') { $('.message').text('사용할 수 있는 ID입니다.') $('.message').css('color','green') $('#id-check').prop('disabled', true) } else { $('.message').css('color', 'red') $('.message').text('이미 사용 중인 아이디입니다.') } }, error:function (data, textStatus) { console.log('error'); } }) }) &lt;/script&gt; Controller.java @PostMapping(\"idcheck\") public void idcheck(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(\"utf-8\"); response.setContentType(\"text/html; charset=utf-8\"); List&lt;Login&gt; list = null; try { list = daoG.getid(request.getParameter(\"id\")); } catch (SQLException e) { throw new RuntimeException(e); } PrintWriter out = response.getWriter(); //배열을 저장할 jObject JSONObject jObject = new JSONObject(); System.out.println(\"아이디 확인용 :\" + list); if (list.size() &gt;= 1) { jObject.put(\"used\", \"yes\"); for (Login check : list) { jObject.put(\"email\", check.getEmail()); } } else { jObject.put(\"used\", \"no\"); } out.print(jObject); } 사용 중인 아이디 사용 가능한 아이디",
    "tags": "Lib Project portfolio ajax",
    "url": "/jekyll-theme-yat/portfolio/2022/11/22/ajax%EB%A1%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%A4%91%EB%B3%B5-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0.html"
  },{
    "title": "댓글 테스트",
    "text": "댓글 테스트 포스트입니다. 참고 글 : https://ansohxxn.github.io/blog/utterances/",
    "tags": "blog",
    "url": "/jekyll-theme-yat/blog/2022/10/29/%EB%8C%93%EA%B8%80-%ED%85%8C%EC%8A%A4%ED%8A%B8.html"
  },{
    "title": "코드블록 테마, 라인 넘버링, 스크롤 색, 로딩 화면 추가",
    "text": "현재 사용중인 깃 볼르그의 테마에 몇가지 문제점이 있습니다. { highlight java linenos }로 코드 넘버 사용 시에만 라인 넘버링 보임. { highlight java linenos }는 ‘```‘와는 달리 사용 시 들여쓰기 안 먹음. 코드 블록 테마가 맘에 안듦. 이런 문제를 해결하기 위해 하이라이트는 이제 그만 사용하고, ‘```’ 사용 시 라인 넘버링 보이도록 수정 및 코드 블록 테마 변경하고 그 외에 스크롤 색 변경과, 로딩화면 추가 하겠습니다. 코드블록 테마 공식 사이트 : https://highlightjs.org 데모 사이트 : https://highlightjs.org/static/demo/ 원하는 테마를 고르고 html에 추가 해줍니다. … html … 저는 기존 테마에서 따로 사용하는 코드 블록 테마가 있길래 그 부분은 지우고 추가했습니다. 기존 css와 충돌이 있어서 수정이 필요했습니다. 저 같은 경우 table 속성이 문제 였는데, 이를 해결하기위해 코드 블록의 table만 table속성을 사용하지 않도록 했습니다. table:not(.hljs-ln) { } 코드 블록 라인 넘버링 html에 js를 추가해주면 끝입니다. &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js\"&gt;&lt;/script&gt; &lt;script&gt;hljs.initLineNumbersOnLoad();&lt;/script&gt; 스크롤 색 변경 css만 추가해주면 됩니다. ::-webkit-scrollbar { width: 10px; } ::-webkit-scrollbar-track { background: #f1f1f1; } ::-webkit-scrollbar-thumb { background: #888; } ::-webkit-scrollbar-thumb:hover { background: #555; } 로딩 화면 로딩 화면을 띄우고, 로딩이 끝나면 로딩 화면을 없앱니다. 저는 이 gif를 사용하도록 하겠습니다. 자바스크립트를 하나 만들어줍니다. $(window).on('load', function() { $('#loading').hide(); }); body에 로딩화면을 추가합니다. &lt;body&gt; ... &lt;div id=\"loading\"&gt;&lt;img id=\"loading-image\" src=\"/이미지 경로/loading.gif\" alt=\"Loading...\" /&gt;&lt;/div&gt; ... &lt;/body&gt; 로딩 화면 css도 추가합니다. /** * Loading */ #loading { width: 100%; height: 100%; top: 0px; left: 0px; position: fixed; display: block; opacity: 0.7; background-color: #fff; z-index: 99; text-align: center; } #loading-image { position: absolute; top: 40%; left: 45%; z-index: 100; } 이렇게하면 전부 끝입니다. 코드 블록 하이라이트를 추가하는데 기존 css와 충돌이 일어나 고치는데 고생했습니다. 그거 말곤 크게 어렵지 않습니다.",
    "tags": "blog",
    "url": "/jekyll-theme-yat/blog/2022/10/28/%EC%BD%94%EB%93%9C%EB%B8%94%EB%A1%9D-%ED%85%8C%EB%A7%88,-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%83%89,-%EB%A1%9C%EB%94%A9-%ED%99%94%EB%A9%B4-%EC%B6%94%EA%B0%80.html"
  },{
    "title": "7. 추상클래스와 인터페이스, 내부 클래스",
    "text": "1. 추상 메서드와 추상 클래스 추상 메서드 추상 메서드: 선언부만 정의하고 구체적인 내용은 비워놓는 메서드. 구체적인 내용을 적지 않았기 때문에 이를 상속받은 하위 클래스에서는 사용하려면 반드시 구현하라는 의미. abctract void methodA(); 추상 클래스 추상 클래스: 추상 메서드를 멤버로 가지는 클래스. 추상 클래스는 일반적인 메서드도 가질 수 있지만 추상 메서드를 하나라도 포함하는 클래스다. 클래스 내부에 추상 메서드가 있다면 반드시 클래스명 앞에 abstract를 붙여아 함. abstract class Cellphone { abstract void mmethodA(); } abstract class Pokemon { String name; abstract void attack(); abstract void sound(); String getName() { return this.name; } } class Pikachu extends Pokemon { Pikachu() { this.name = \"피카츄\"; } @Override void attack() { System.out.println(\"전기 공격\"); } @Override void sound() { System.out.println(\"피카 피카!\"); } } class Squirtle extends Pokemon { Squirtle() { this.name = \"꼬부기\"; } @Override void attack() { System.out.println(\"물 공격\"); } @Override void sound() { System.out.println(\"꼬북 꼬북!\"); } } public class abstract_ { public static void main(String[] args) { Pikachu pikachu = new Pikachu(); System.out.println(\"이 포켓몬은 :\" + pikachu.getName()); pikachu.attack(); pikachu.sound(); Squirtle squirtle = new Squirtle(); System.out.println(\"이 포켓몬은 :\" + squirtle.getName()); squirtle.attack(); squirtle.sound(); } } 2. 인터페이스(interface) 인터페이스란? 인터페이스: inter(사이의) + face(마주하다)의 합성어. 즉 물체들 사이에서 상호작용을 하기 위한 매개역할을 하는 것. 클래스가 설계도라면 인터페이스는 설계할 때 피리요한 목록을 써놓은 종유에 비유함. 종이를 바탕으로 설계도를 작성하듯 프로그래머는 인터페이스를 바탕으로 클래스를 작성함. interface 인터페이스이름{ public static final 타입 이름 = 값; 타입 이름 = 값; // 제어자 생략 가능 public abstract 반환타입 메서드이름(매개변수); // 제어자 생략 가능 반환타입 메서드이름(매개변수); // 제어자 생략 가능 } 인터페이스는 상속한다는 말 대신에 구현한다는 말을 사용함. 자손 클래스는 키워드 implements를 사용해서 인터페이스를 구현함. 인터페이스를 구현한 자손 클래스는 오버라이딩을 통하여 인터페이스 내부의 추상 메서드를 구체적으로 구현해야 함. interface A{ int a = 4; void methodA(); void methodB(); } class B implements A{ public void methodA(){ //구체적으로 구현, 오버라이딩 } public void methodB(){ //구체적으로 구현, 오버라이딩 } } 오버라이딩을 할 때는 부모의 접근제어자보다 더 넓거나 같은 범위의 제어자를 사용해야 하므로, public 제어자를 붙이고 오버라딩 해야함. 하나의 클래스가 상속을 받으면서 구현을 동시에 할 수도 있음. calss B extends C implements A{ // C의 멤버 // A의 멤버 } 이때 자손 클래스는 부모 클래스의 멤버와 인터페이스의 멤버를 모두 갖게 됨. 또한 인터페이스 간에도 상속이 가능함. 클래스는 다중상속이 불가능했지만 인터페이스는 다수의 인터페이스를 구현할 수 있으므로 다중상속이 가능함. interface A{ void methodA(); } interface B{ void methodB(); } interface C exteds A,B{ } C는 추상 메서드 methodA와 methodB를 멤버로 상속받게 됨. 이때 C는 A와 B를 합친 종합적인 기능을 다루는 인터페이스이다. 인터페이스의 실제 활용 인터페이스는 객체 간의 상호작용을 위한 일종의 규악임. A 프로그래머와 B프로그래머가 하나의 프로젝트를 진행했을 때, A 프로그래머와 B 프로그래머가 서로의 클래스가 완성되지 않았어도, 구현해야 할 기능들을 미리 협의하고 반환타입을 정해 놓으면 서로의 작업의 정도와는 무관하게 진행함. 바로 이런 약속과 같은 것이 인터페이스이다. interface Providable { void leisureSports(); void sightseeing(); void food(); } class KoreaTour implements Providable { @Override public void leisureSports() { // TODO Auto-generated method stub System.out.println(\"한강에서 수상스키 투어\"); } @Override public void sightseeing() { // TODO Auto-generated method stub System.out.println(\"경복궁 관람 투어\"); } @Override public void food() { // TODO Auto-generated method stub System.out.println(\"전주 비빔밥 투어\"); } } class JapanTour implements Providable { @Override public void leisureSports() { // TODO Auto-generated method stub System.out.println(\"도쿄타워 번지점프 투어\"); } @Override public void sightseeing() { // TODO Auto-generated method stub System.out.println(\"오사카 관람 투어\"); } @Override public void food() { // TODO Auto-generated method stub System.out.println(\"초밥 투어\"); } } class EUTour implements Providable { @Override public void leisureSports() { // TODO Auto-generated method stub System.out.println(\"스카이다이빙 투어\"); } @Override public void sightseeing() { // TODO Auto-generated method stub System.out.println(\"알프스 관람\"); } @Override public void food() { // TODO Auto-generated method stub System.out.println(\"피자 투어\"); } } class TourGuide { private Providable tour = new EUTour(); // 인터페이스로 타입 선언 public void leisureSports() { tour.leisureSports(); } public void sightseeing() { tour.sightseeing(); } public void food() { tour.food(); } } public class interface_정리 { public static void main(String[] args) { // TODO Auto-generated method stub TourGuide guide = new TourGuide(); guide.leisureSports(); guide.sightseeing(); guide.food(); } } 인터페이스와 다형성 특정한 인터페이스를 구현한 인스턴스는 해당 인터페이스 타입의 참조변수로 참조가 가능함. 인터페이스명 참조변수이름 = new 클래스명(); interface Camera { void Photo(); } interface Call { void calling(); } interface Memo { void write(); } interface Clock { void clock(); } class MyCellPhone implements Camera, Call, Memo, Clock { @Override public void clock() { // TODO Auto-generated method stub } @Override public void write() { // TODO Auto-generated method stub } @Override public void calling() { // TODO Auto-generated method stub } @Override public void Photo() { // TODO Auto-generated method stub } } class PhoneUser { void call(Call c) { // 인터페이스 Call의 calling 메소드 대입. System.out.println(\"전화를 걸었습니다.\"); } void memo(Memo m) { // 인터페이스 Memo의 memo 메소드 대입. System.out.println(\"메모 작성.\"); } void camera(Camera c) { // 인터페이스 Camera의 photo 메소드 대입. System.out.println(\"카메라 기능 켬.\"); } void clock(Clock c) { // 인터페이스 Call의 calling 메소드 대입. System.out.println(\"시간 보기.\"); } } public class interface_정리 { public static void main(String[] args) { // 각 클래스 메소드 : PhoneUser, call(); // 각 클래스 메소드 : MyCellPhone : clock();, write();, calling();, Photo(); MyCellPhone phone1 = new MyCellPhone(); // 네 가지 기능 다 가능 Camera phone2 = new MyCellPhone(); // 카메라만 사용가능 Call phone3 = new MyCellPhone(); // 전화만 가능 Memo phone4 = new MyCellPhone(); // 메모만 가능 Clock phone5 = new MyCellPhone(); // 시계만 가능 PhoneUser user1 = new PhoneUser(); user1.call(phone3); user1.call(phone1); user1.memo(phone1); user1.memo(phone4); user1.camera(phone1); user1.camera(phone2); user1.clock(phone1); user1.clock(phone5); } } 하나의 객체를 여러가지 타입으로 참조할 수 있는 것이 다형성임. 3. 내부 클래스 내부 클래스란? 내부 클래스: 어떠한 클래스의 내부에 성생된 클래스. 클래스가 설계도라면 내부 클래스느 큰 틀의 설계도를 완성하기 위한 내부 부품의 설계도. class OuterClass{ // 외부 클래스 class InnerClass{ // 내부 클래스 } } 내부 클래스를 사용하면 추가적으로 코드를 간결하게 만들 수 있음. 하나의 클래스의 내부에 클래스를 감추어 캡슐화할 수 있게 된다. 내부 클래스의 종류 인스턴스 클래스 스태틱 클래스 지역 클래스 내부 클래스의 접근성 ``` java class C { static class StaticInner { } class InstanceInner { } StaticInner st1 = new StaticInner(); // 스태틱 멤버간의 접근 가능 InstanceInner ii1 = new InstanceInner(); // 인스턴스 멤버간의 접근 가능 static void StaticMothod() { StaticInner st2 = new StaticInner(); // InstanceInner ii3 = new InstanceInner(); // (error)스태틱 멤버는 인스턴스 멤버에 접근 불가. } void InstanceMoethod() { InstanceInner ii2 = new InstanceInner(); StaticInner st3 = new StaticInner();// 인스턴스 멤버는 모두 접근 가능. } } class OuterClass { class InnerInstance {// 인스턴스 클래스 : 어떤 클래스에서든 호출이 가능 } static class InnerStatic { // 스태틱 클래스 : 스태틱 내부 클래스 끼리만 호출이 가능 } abstract class Innerinstnace1 { // 내부 클래스 접근성 abstract void chat(); } private class InnerInstance2 { // 내부 클래스 접근성 } protected class InnerInstance3 { // 내부 클래스 접근성 } } class OuterClass1 { int a = 3; static int b = 4; class Inner { // 인스턴스 클래스는 인스턴스 변수만 가능. int c = 5; public void innerMethod() { System.out.println(\"&lt;Inner Class&gt;\"); } } static class StaticInner { // 스태틱 클래스는 인스턴스, 클래스 변수 모두 가능. int d = 6; // 인스턴스 변수 static int stat = 0; // 클래스 변수 public static void staticMethod() { System.out.println(\"&lt;Static Inner&gt;\"); } } } //익명 클래스 //일반적인(기존) 방법 class Some { // private int a를 가져오지 못해서 setter 메소드를 만들고, getter에 int a의 값을 받는다. private int a = 3; int getter() { return this.a; } void setter(int a) { this.a = a; } void a() { System.out.println(\"만듦\"); } } public class innerclass정리 { public static void main(String[] args) { // TODO Auto-generated method stub OuterClass1 oc = new OuterClass1(); System.out.println(\"OuterClass1의 a값 : \" + oc.a); // a의 값을 oc인스턴스로 접근 System.out.println(\"OuterClass1의 b값 : \" + OuterClass1.b); // b는 스태틱변수이므로 클래스 이름 자체로 접근 가능 System.out.println(\"\\n=== inner 클래스 접근하기 ===\"); OuterClass1 oc2 = new OuterClass1(); // 인스턴스 변수 접근 -&gt; 인스턴스명.변수명 = new 인스턴스명 OuterClass1.Inner i = oc2.new Inner(); // 인스턴스 변수 접근 -&gt; 인스턴스명.변수명 = new 인스턴스명 System.out.println(\"Inner의 c값 = \" + i.c); i.innerMethod(); OuterClass1.StaticInner si = new OuterClass1.StaticInner(); // 클래스 변수 접근 -&gt; 클래스명.변수명 System.out.println(\"StaticInner의 d값 = \" + si.d); // int d가 static int d라면 OuterClass1.StaticInner.d로 가능. Ch07_inheritance_N_Polymorphism.OuterClass1.StaticInner.staticMethod(); OuterClass1.StaticInner.staticMethod(); // 스태틱 클래스의 스태틱 메서드는 클래스의 이름만으로도 참조 // 익명클래스 : // 일반적인(기존) 방법 Some s1 = new Some(); s1.setter(4); System.out.println(s1.getter()); s1.a(); // 익명 클래스 Some anooy = new Some() { // 인스턴스 생성할 때 블록 안에 클래스 내용 새로 정의 private int a = 3; // Some클래스 오버라이딩 int getter() { return this.a; } void setter(int a) { this.a = a; } void a() { System.out.println(\"새로만듦\"); } }; // 세미콜론 주의 anooy.setter(5); System.out.println(anooy.getter()); anooy.a(); // 오버라이딩 재정의 } } ``` 익명 클래스 익명 클래스: 말 그대로 이름이 없는 클래스. class OuterClass1 // a와 b라는 메서드를 가진 클래스 { void a(){ System.out,println(\"metohd a\"); } void b(){} } class Anonymous { public static void main(String[] args) { OuterClass1 o = new OuterClass1() { void a(){ // 익명 클래스 안에 있는 메서드는 객체 o를 통해서만 가능하다. System.out.println(\"새롭게 정의한 익명 클래스의 메서드입니다.\"); } }; // 익명 클래스는 반드시 마지막에 ;를 붙여아 한다. o.a(); // 익명 클래스로 오버라이드한 메서드를 출력 OuterClass1 ok = new OuterClass1(); ok.a(); // 익명 클래스는 일회용이므로 다시기존의 메서드가 출력. } } 새롭게 정의한 익명 클래스의 메서드입니다. metohd a",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/28/7.-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4,-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4.html"
  },{
    "title": "6. 상속과 다형성",
    "text": "1. 상속이란? 상속: 새로운 클래스를 작성할 때 기존에 존재하는 클래스를 물려 받아 이용. 기존의 클래스가 가진 멤버를 물려받기 때문에 새롭게 작성해야 할 코드의 야이 줄어드는 효과가 있음. 이때 자신의 멤버를 물려주는 클래스를 부모 클래스 또는 조상 클래스라고 하고 상속받는 클래스를 자식 클래스 또는 자손 클래스라고 함. 상속할 때는 새롭게 작성할 클래스 선언 부분 뒤에 ‘extends 부모 클래스 이름’을 붙입니다. class Parents{} class Child extends Parents{} // Parents 클래스의 멤버들을 상속 받음. class Person { void breath() { System.out.println(\"숨쉬기\"); } void eat() { System.out.println(\"밥먹기\"); } void say() { System.out.println(\"말하기\"); } } class Student extends Person { // 부모 - Person void learn() { System.out.println(\"배우기\"); } } class Teacher extends Person { // 부모 - Person void teach() { System.out.println(\"가르치기\"); } } public class chapter7 { public static void main(String[] args) { // TODO Auto-generated method stub Student s1 = new Student(); s1.breath(); // 부모에게 상속 받은 기능은 선언없이 사용 가능. s1.eat(); // 부모에게 상속 받은 기능은 사용 가능. s1.say(); // 부모에게 상속 받은 기능은 사용 가능. s1.learn(); // Student의 기능. Teacher t1 = new Teacher(); t1.breath(); // 부모에게 상속 받은 기능은 사용 가능. t1.eat(); // 부모에게 상속 받은 기능은 사용 가능. t1.say(); // 부모에게 상속 받은 기능은 사용 가능. t1.teach(); // Teacher의 기능. } } 숨쉬기 배우기 밥먹기 가르치기 2. 오버라이딩(Overriding) 오버라이딩: 자손 클래스에서 부모 클래스로부터 물려받은 메서드를 다시 작성하는 것 class Parents { void method() { // 부모 클래스의 메서드 } } class Child extends Parents { void method() { // w자손 클래스에서 메서드 내용을 재정의 } } class Students { void lean() { System.out.println(\"배우기\"); } void eat() { System.out.println(\"밥먹기\"); } void say() { System.out.println(\"선생님 안녕하세요.\"); } } class Leader extends Students { @Override // Source - Overrrid/Implement Method... void lean() { // TODO Auto-generated method stub super.lean(); // super : 클래스명 대신에 사용. 부모의 클래스 지칭. } @Override // Source - Overrrid/Implement Method... void eat() { // TODO Auto-generated method stub super.eat(); // super : 클래스명 대신에 사용. 부모의 클래스 지칭. } @Override // Source - Overrrid/Implement Method... void say() { System.out.println(\"선생님께 인사.\"); // say 재정의 } } //this : 클래스명 대신에 사용. 자기 자신의 클래스 지칭. //super : 클래스명 대신에 사용. 부모의 클래스 지칭. public class Overriding { public static void main(String[] args) { // TODO Auto-generated method stub Students s1 = new Students(); Leader l1 = new Leader(); l1.eat(); l1.say(); } } 밥먹기 선생님께 인사 3. 상속과 생성자 super() 부모 클래스의 생성자 호출은 상위 클래스를 위미하는 super라는 키워드에 ()를 붙인 super()을 통해 이루어짐. 부모 클래스 호출은 무조건 자식 클래스 성생자 첫 줄에 이루어짐. 만약 자식의 생성자 내부에 부모 클래스의 생성자를 딸 ㅗ작성하지 않았다면 자동적으로 컴파일러는 자식 클래스의 생성자 첫 줄에 super();을 추가함. Object 클래스 Object 클래스: 모든 클래스의 조상인 클래스. 어떤 클래스라도 상속 관계를 따라 거슬러 올라가면 마지막에는 Object 클래스가 있음. 4. Package와 import package란? package: 클래스를 모아놓은 일종의 집합. 만약 단순한 프로그램이 아니라 규모가 큰 작업을 할 때는 상당히 많은 클래스를 사용함. 이떄 유지보수 및 관리를 용이하게 하기 위해서 관련 있는 클래스끼리 묶어서 분리하는 일종의 디렉터리로서 package를 사용함. import 다른 패키지에 있는 클래스를 사용하고 싶을 때 클래스의 이름으로 참조함. import 패키지명.클래스명; 5. 제어자 접근 제어자 ``` 접근제어자 public : 접근 제한이 없음 protected : 같은 패키지 내에서와 자손 클래스에서 접근 가능 default : 같은 패키지 내에서만 접근 가능 private : 같은 클래스 내에서만 접근 가능 ``` static statc제어자는 변수나 메서드 앞에 붙어서 이 멤버가 클래스 멤버라는 것을 의미함. final fianl은 문자 그대로 ‘종결의’라는 의미를 가짐. final이 붙으면 내용이나 값을 변경하지 못하게 됨. ``` 예제 final 변수 : 값을 더 이상 변경할 수 없는 상수. final 메서드 : 내용을 더 이상 변경할 수 없는 메서드, 오버라아딩 불가. final 클래스 : 내용을 더 이상 변경할 수 없는 클래스, 상속 불가. ``` 6. 다형성 다형성이란? 다형성은 사전적 의미로 ‘여러 형태를 가지는 성질’을 뜻함. 객체지향 개념에서 다형성은 ‘한 가지 타입이 여러 가지 형태의 인스턴스를 가질 수 있다’라는 의미. 특히, 부모 타입 변수에는 모든 자식 인스턴스들이 대입될 수 있는데, 이 점은 객체지향 언어의 중요한 특징 중의 하나입니다. A obj = new B(); (클래스 B가 A를 상속할 떄) 참조변수와 인스턴스 간의 관계 다형성을 이용할 때 중요한 것 중의 하나는 조상 클래스 타입의 참조변수로 자손 인스턴스를 참조하는 것은 가능하지만 그 반대의 경우는 에러가 발생하는 것이다. 자손 클래스는 부모 클래스를 상속하면서 부모의 멤버들에 자신의 멤버들을 더해 확장된다. 부모 클래스의 참조변수에서 자손 클래스의 인스턴스를 참조할 때 주의할 점은 부모 클래스의 참조변수로 참조가 불가능한 멤버가 존재한다는 점입니다. 다형성의 활용 ``` java /** * 다향성의 활용. * 조상 클래스 : Animal * 자손 클래스 : Lion, Rabbit, Monkey * * ZooKeeper 클래스 feed 함수는 Animal을 받아서 출력. * */ package Ch07_inheritance_N_Polymorphism; class Animal { void breath() { System.out.println(\"숨쉬기\"); } } class Lion extends Animal { // 동물 클래스를 상속한 사자 클래스 public String toString() { return \"사자\"; } } class Rabbit extends Animal { // 동물 클래스를 상속한 토끼 클래스 public String toString() { return \"토끼\"; } } class Monkey extends Animal { // 동물 클래스를 상속한 원숭이 클래스 public String toString() { return \"원숭이\"; } } class ZooKeeper { void feed(Animal animal) { // 사육사 클래스 System.out.println(animal + \"에게 먹이주기\"); } } public class Polymorphism4 { public static void main(String[] args) { ZooKeeper james = new ZooKeeper(); Animal lion1 = new Lion(); Animal Rabbit1 = new Rabbit(); Animal Monkey1 = new Monkey(); james.feed(lion1); james.feed(Rabbit1); james.feed(Monkey1); } } ``` ``` 실행결과 사자에게 먹이주기 토끼에게 먹이주기 원숭이에게 먹이주기 ```",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/27/6.-%EC%83%81%EC%86%8D%EA%B3%BC-%EB%8B%A4%ED%98%95%EC%84%B1.html"
  },{
    "title": "5. 클래스",
    "text": "1. 객체지향 언어란? 객체지향 언어 현실에서 존재하는 사물과 개념들을 소프트웨어적으로 구현하고, 그 구현된 객체들이 상호작용하여 데이터를 처리하는 방식. 객체지향 언어의 특징 : 코드의 재사용성. 신뢰성 높은 프로그래밍. 코드 관리의 편리함. 2. 클래스와 객체 클래스란? ‘클래스’는 객체의 설계도와 같은 역할을 함. 클래스에는 객체의 속성과 기능들이 정의되어 있고 이를 통해서 객체를 생성합니다. 인스턴스 인스턴스: 클래스를 통해 만들어진 형태. 클래스를 통해 객체를 만드는 과정을 클래스의 인스턴스화라고 함. 클래스의 사용 ``` 예제 class 클래스명{ /* 속성(변수) 작성 */ /* 기능(메서드) 작성 */ } ``` 3. 인스턴스변수와 클래스변수 인스턴스 변수 인스턴스 변수: 객체마다 가지는 고유한 번수. 인스턴스를 생성할 떼 만들어지며 인스턴스마다 고유의 저장 공간을 가지므로 각각의 다른 값을 가질 수 있음. class Cars{ int speed; // 인스턴스 변수 선언 // 기존의 방식과 동일! } 클래스 변수 클래스 변수: 모든 인스턴스가 공통된 값을 공유하는 변수. 인스턴스 변수와는 달리 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있음. calss Cars{ static int wheel; // 클래스 변수 선언 } 4. 메서드 메서드란? 메서드: 함수라고도 불리는 메서드는 특정한 작업이나 논리를 구성하는 코드를 괄호로 묶어 놓은 것. 메서드는 입력 값을 받아서 내부에서 처리하여 결과를 출력 또는 반환하는 역할을 함. 메서드는 한 번 정해놓으면 언제던지 호출할 수 있고 다른 프로그램에서도 사용함. 이러한 재 사용성은 프로그래머에게 상당히 효율적이고 코드의 중복을 피할 수 있게 도와줌. 메서드의 사용 ``` 예제 반환타입 메서드명(타입 변수명, 타입 변수명) { // 메서드 내부의 동작 return 값; } ``` 반환타입 : 메서드의 반환 값의 타입을 정해줌. 메서드명 : 자유롭게 지을 수 있으며 소문자로 시작하는 것이 일반적. 매개변수 : 메서듸 명의 뒤의 괄호 안에 위치함. 타입과 변수명으로 이루어졌으며 파라미터라고도 불림. return문은 메서드 내부의 결과 값을 반환하는 역할을 함. 반환타입이 void인 경우를 제외하고는 반드시 메서드 내부에 return문이 포함되어 있어야함. 메서드의 종류 메서드도 클래스 메서드와 인스턴스 메서드로 구분됨. 메서드 앞에 static이 붙어있으면 클래스 메서드. boolean powerOn(){} // 인스턴스 메서드 static boolean wipeOn(){} // 크랠스 메서드 클래스 멤버와 인스턴스 멤버간의 참조 및 호출 클래스 변수와 클래스 메서드를 클래스 멤버, 인스턴스 변수와 인스턴스 메서드를 인스턴스 멤버라고 부름. 같은 클래스에 속한 멤버들끼리는 인스턴스를 생성하지 않고 변수를 참조하거나 메서드를 호출함. 하지만 클래스 메서드로 인스턴스 멤버들을 참조하는 것은 에러가 발생함. 그 이유는 클래스 멤버가 존재하는 시점은 처음 클래스가 메모리에 올라갈 때인데 이 시점에서 인스턴스 멤버는 존재하지 않기 때문. 인스턴스 멤버의 클래스 멤버 사용 -&gt; 가능 클래스 멤버의 인스턴스 멤버 사용 -? 에러 인스턴스 멤버의 인스턴스 멤버 사용 -&gt; 가능 클래스 멤버의 클래스 멤버 사용 -&gt; 가능 5. 오버로딩 메서드의 이름이 같지만 파라미터가 다른 경우. int sum(int a, int b) { return a + b; } int sum(int a, int b, int c) { return a + b + c; } class Overloading1 { int sum(int a, int b) { System.out.println(\"인자가 둘일 경우 호출됨\"); return a + b; } int sum(int a, int b, int c) { System.out.println(\"인자가 셋일 경우 호출됨\"); return a + b + c; } double sum(double a, double b, double c) { System.out.println(\"double 타입일 경우 호출됨\"); return a + b + c; } } public class OverLoading { static int sum(int a, int b) { System.out.println(\"인자가 둘일 경우 호출됨\"); return a + b; } static int sum(int a, int b, int c) { System.out.println(\"인자가 셋일 경우 호출됨\"); return a + b + c; } static double sum(double a, double b, double c) { System.out.println(\"double 타입일 경우 호출됨\"); return a + b + c; } public static void main(String[] args) { // TODO Auto-generated method stub Overloading1 overload = new Overloading1(); System.out.println(overload.sum(3, 2)); System.out.println(overload.sum(2, 3, 4)); System.out.println(overload.sum(2.5, 3.5, 4.5)); System.out.println(sum(3, 2)); System.out.println(sum(2, 3, 4)); System.out.println(sum(2.5, 3.5, 4.5)); } } 인자가 둘일 경우 호출됨 5 인자가 셋일 경우 호출됨 9 double 타입일 경우 호출됨 10.5 6. 생성자 생성자: 인스턴스를 생성할 때 호출되어 인스턴스 변수들을 초기화하는 일종의 메서드. 생성자의 이름은 클래스의 이름과 같으며 생성자에는 리턴 값이 없음. 기본 생성자 ``` 예시 클래스이름() {} class Cellphone{ String model;s String color; int capacity; Cellphone() { /* 필요한 작업 */ } // 컴파일 시 컴파일러가 자동으로 추가. } ```",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/27/5.-%ED%81%B4%EB%9E%98%EC%8A%A4.html"
  },{
    "title": "Markdown 정리",
    "text": "블로그를 작성하는데 마크다운 언어가 익숙하지 않아 쉽지가 않습니다. 그리고 적용한 테마와 일반적인 마크다운 언어가 조금 차이가 있는 거 같아 따로 정리합니다. 게시글로 정리해두고, 기억나지 않을 때 마다 참고하려고 만들었습니다. 글머리 글머리는 ##부터 사용한다. 일반적으로 #부터지만 이 테마에선 ##부터 시작인듯 하다. 인용문자 인용문자는 &gt;를 사용한다 인용 인용에 인용 이 안에서는 다른 마크다운 요소를 포함할 수 있다. 목록 순서 있는 목록 1. 첫번째 2. 두번째 3. 세번째 첫번째 두번째 세번째 순서 없는 목록( *, +, - ) * 목록1 + 목록2 + 목록3 목록1 목록2 목록3 코드 라인 숫자가 없는 코드 ``` 프로그래밍이름 내용 ``` 라인 숫자가 있는 코드 1 2 3 수평선 * * * *** ***** - - - --------------------------------------- 링크 개인적으로 외부링크가 더 편함. 참조링크 Link: [Google][googlelink] [googlelink]: https://google.com \"Go google\" Link: Google 외부링크 [Google](https://google.com, \"google link\") Google 자동 연결 일반적인 URL 혹은 이메일주소인 경우 적절한 형식으로 링크를 형성한다. * 외부링크: &lt;http://example.com/&gt; * 이메일링크: &lt;address@example.com&gt; 외부링크: http://example.com/ 이메일링크: address@example.com 강조 *single asterisks* _single underscores_ **double asterisks** __double underscores__ ~~cancelline~~ single asterisks single underscores double asterisks double underscores cancelline 이미지 ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg \"Optional title\") 사이즈 조절 기능은 없기 때문에 &lt;/img&gt;를 이용한다. &lt;img src=\"/path/to/img.jpg\" width=\"450px\" height=\"300px\" title=\"px(픽셀) 크기 설정\" alt=\"RubberDuck\"&gt;&lt;/img&gt; 출처 : [공통] 마크다운 markdown 작성법",
    "tags": "markdown Markdown",
    "url": "/jekyll-theme-yat/markdown/2022/10/26/Markdown-%EC%A0%95%EB%A6%AC.html"
  },{
    "title": "4. 배열",
    "text": "1. 배열이란? 배열은 같은 타입의 변수를 하나의 묶음으로 관리. 변수가 하나의 데이터만 저장할 수 있다면 배열은 여러 개의 데이터를 저장하고 효율적으로 관리함. //배열을 사용하지 않을 경우 int a1, a2, a3, ... a50, ... a100; //배열을 사용할 경우 int[] a = new int[100]; 2. 배열의 사용 배열의 선언과 생성 // 배열 선언 타입[] 배열이름; int[] stuendt; String[] name; // 길이 생성 배열이름 = new 타입[길이]; student = new int[30]; name = new String[3]; // 배열 선언과 생성 int[] student = new int[5]; Stirng[] name = new String[10]; 배열의 길이와 인덱스 인덱스: 배열의 공간마다 붙여진 번호. 0번부터 시작함. 예를들어 길이가 3인 배열 a을 선언했다면 a[0], a[1], a[2]가 된다. 배열의 초기화와 출력 test import java.util.Arrays; public class Array_1 { public static void main(String[] args) { int[] student = new int[3]; System.out.println(\"현재 자동으로 초기화 된 값:\" + student[0]); student[0] = 30; student[1] = 20; student[2] = 10; System.out.println(\"현재 첫 번째 요소의 값 = \" + student[2]); // 길이가5인 배열 생성, 배열 길이 생략 int[] a = new int[] { 10, 20, 4, 25, 18 }; // 길이가 7인 배열 생성 new int는 생략 가능. int[] b = { 1, 2, 3, 4, 5, 6, 7 }; // for문으로 배열 초기화 int[] c = new int[10]; // 배열 길이를 10으로 for (int i = 0; i &lt; c.length; i++) { c[i] = i; } // for문을 이용한 출력 for (int i = 0; i &lt; c.length; i++) { System.out.print(c[i]); } System.out.println(\"\"); System.out.println(Arrays.toString(c)); } } 현재 자동으로 초기화 된 값:0 현재 첫 번째 요소의 값 = 10 0123456789 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 3. 다차원 배열 다차원 배열: 많은 데이터를 ㅕㄴ하게 관리하기 위해 귀조화시키는 것으로 2차원 이상의 배열을 다차원 배열이라고 함. 2차원 배열의 선언과 생성 타입[][] 배열이름; int[][] student; String[][] name; 2차원 배열을 생성할 때는 첫 번째 괄호에 들어가는 수는 2차원 배열의 행이 되고 두 번째 괄호에 들어가는 수는 2차원 배열의 열이 됨. 2차원 배열의 인덱스 2차원 배열은 행과 열로 구성됨. int[][] sudent = new int[3][4]; student[0][0] student[0][1] student[0][2] student[0][3] student[1][0] student[1][1] student[1][2] student[1][3] student[2][0] student[2][1] student[1][2] student[2][3] student[1][2] = 30; // 2행 3열에 30 저장. 2차원 배열의 초기화와 출력 2차원 배열을 초기화할 때는 행을 구분하기 위해 괄호를 한 번 더 사용함. 내부에 들어있는 묶음 중에 첫 번째 묶음이 1행, 두 번째 묶음이 2행 int[][] a = { {100, 200, 300}, {400, 500, 600}, {700, 800, 900}, {200, 400, 500} } 4. 배열다루기 배열의 복사 System.arraycopy() 메서드 System.arraycopy(src, srcPos, destPos, length); 1. src : 복사할 배열, 2. srcPos : 복사를 하기 시작할 인덱스 3. dest : 덮어쓸 배열, 4. destPos : 덮어쓰기 시작할 인덱스 5. length : 복사할 길이 import java.util.Arrays; public class ArrayCopy { public static void main(String[] args) { int[] a = { 1, 2, 3, 4, 5, 6 }; int[] b = { 0, 0, 0, 0, 0, 0, 0 }; System.out.println(Arrays.toString(a)); System.out.println(Arrays.toString(b)); System.arraycopy(a, 2, b, 1, 4); System.out.println(Arrays.toString(b)); } } [1, 2, 3, 4, 5, 6] 0, 0, 0, 0, 0, 0, 0] [0, 3, 4, 5, 6, 0, 0] foreach 자바에서는 배열을 순활할 때 기존의 반복문보다 편리한 작업을 할 수 있도록 foreach문을 제공함. for(배열의타입 변수이름 : 배열이름) // 실행 구문 public class Array_5_Foreach { public static void main(String[] args) { // TODO Auto-generated method stub // string String[] numbers = { \"one\", \"two\", \"three\" }; for (int i = 0; i &lt; numbers.length; i++) { // 기존 // System.out.println(numbers[i]); } for (String i : numbers) { // foreach // System.out.println(i); } // int int[] number = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }; for (int j : number) { // System.out.println(j); } // 홀수만 int[] numberodd = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }; for (int j : numberodd) { if (j % 2 == 1) { // System.out.println(j); } } // 짝수만 int[] numbereven = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }; for (int j : numbereven) { if (j % 2 == 0) { if (j != 0) {// 0이 아닐 때 System.out.println(j); } } } } }",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/26/4.-%EB%B0%B0%EC%97%B4.html"
  },{
    "title": "3. 제어문",
    "text": "조건문 if문 if(조건식) // 실행부분 조건식 : 식의 결과가 참 또는 거짓으로 구분될 수 있는 문장 실행부분 : 조건식의 결과가 참이면 실행할 문장. public class If_else { public static void main(String[] args) { int a = 5; if( a &gt; 3 ){ System.out.println(\"a는 3보다 큽니다.\"); } System.out.println(\"검사가 끝났습니다.\"); } } a는 3보다 큽니다. 검사가 끝났습니다. if-else문 if-else: if문의 구조에서 조건식이 false일 경우에 실행 되는 부분을 추가한 문장. if(조건식){ // 참 일때 실행부분 } else { // 참이 아닐 때 실행부분 } public class If_else { public static void main(String[] args) { int age = 15; if( age &gt; 19 ) { System.out.println(\"성인입니다.\"); System.out.println(\"성인 요금이 적용됩니다.\"); } else { System.out.println(\"청소년입니다.\"); System.out.println(\"청소년 요금이 적용됩니다.\"); } System.out.println(\"결제를 진행해주세요.\"); } } 청소년입니다. 청소년 요금이 적용됩니다. 결제를 진행해주세요. if-else if if-else if: 조건이 여러 가지일 경우 조건에 따라 각각 다른 작업을 수행하고 싶을 때 사용. if(조건1) { // 조건1이 참이면 실행. } else if(조건2) { // 조건2가 참이면 실행. } else if(조건3) { // 조건3이 참이면 실행. } else { // 위 조건에 해당되지 않으면 실행. } 중첩 if문 중첩 if문: if문의 실행 부분에 다시 if문을 중첩해서 쓰는 문장. if(조건1) { // 조건1이 참일 때 실행. if(조건2) { // 조건1이 참이고, 조건2가 참이면 실행. } } else { // 조건 1이 참이 아닐 때 실행. } switch문 switch문: 하나의 조건식으로 많은 경우의 수를 처리하는 조건문. switch(조건식){ case 값1: // 조건식의 결과와 값1이 같은 경우 실행. break; case 값2: // 조건식의 결과와 값2이 같은 경우 실행. break; default: // 조건식의 결과와 일치하는 값이 없을 때 실행. } import java.util.Scanner; public class switch_test { public static void main(String[] args) { // TODO Auto-generated method stub int score; char grade; System.out.print(\"당신의 성적을 입력하세요 :\"); Scanner input = new Scanner(System.in); score = input.nextInt() / 10; switch (score) { case 10: grade = 'A'; break; case 9: grade = 'A'; break; case 8: grade = 'B'; break; case 7: grade = 'C'; break; case 6: grade = 'D'; break; default: grade = 'F'; } if (score == 10) { System.out.println(\"만점입니다.\"); System.out.println(\"당신의 학점은 \" + grade + \"입니다.\"); } else { System.out.println(\"당신의 학점은 \" + grade + \"입니다.\"); } } } 반복문 for문 for문: 특정한 횟수동안 작업을 반복하고 싶을 때 사용하는 반복분. for( 초기화; 조건식; 증감식) { // 조건식이 참일 때 실행되는 부분. } public class For { public static void main(String[] args) { // 1. 1~100 홀수 누적, 2. 누적된 값이 1000미만까지 최종합과 i의 값 구하기. int i = 0; int i1 = 0; int sum = 0; int sum1 = 0; for (i = 1; i &lt;= 100; i++) { if (i % 2 == 0) { sum += i; if (sum &lt; 1000) { sum1 += i; i1 = i; } } } System.out.printf(\"1에서 100 중, 홀수 총합이 1000미만일 때의 최종합은 %d이고 그 때 i는 %d이다.\", sum1, i1); } } 1에서 100 중, 홀수 총합이 1000미만일 때의 최종합은 992이고 그 때 i는 62이다. while문 while문: 조건식을 검사하고 조건식이 참이면 반복하고 거짓이면 while문 전체를 벗어남. while(조건식) { // 실행되는 부분 } while문을 이용하여 구구단 만들기. public class While { public static void main(String[] args) { // 구구단 i단(a * b)=output int row = 2; while (row &lt; 10) { int column = 1; while (column &lt; 10) { System.out.printf(\"%3d*%d = %2d,\", row, column, row * column); column++; } System.out.printf(\"\\n\"); row++; } } } 2*1 = 2, 2*2 = 4, 2*3 = 6, 2*4 = 8, 2*5 = 10, 2*6 = 12, 2*7 = 14, 2*8 = 16, 2*9 = 18, 3*1 = 3, 3*2 = 6, 3*3 = 9, 3*4 = 12, 3*5 = 15, 3*6 = 18, 3*7 = 21, 3*8 = 24, 3*9 = 27, 4*1 = 4, 4*2 = 8, 4*3 = 12, 4*4 = 16, 4*5 = 20, 4*6 = 24, 4*7 = 28, 4*8 = 32, 4*9 = 36, 5*1 = 5, 5*2 = 10, 5*3 = 15, 5*4 = 20, 5*5 = 25, 5*6 = 30, 5*7 = 35, 5*8 = 40, 5*9 = 45, 6*1 = 6, 6*2 = 12, 6*3 = 18, 6*4 = 24, 6*5 = 30, 6*6 = 36, 6*7 = 42, 6*8 = 48, 6*9 = 54, 7*1 = 7, 7*2 = 14, 7*3 = 21, 7*4 = 28, 7*5 = 35, 7*6 = 42, 7*7 = 49, 7*8 = 56, 7*9 = 63, 8*1 = 8, 8*2 = 16, 8*3 = 24, 8*4 = 32, 8*5 = 40, 8*6 = 48, 8*7 = 56, 8*8 = 64, 8*9 = 72, 9*1 = 9, 9*2 = 18, 9*3 = 27, 9*4 = 36, 9*5 = 45, 9*6 = 54, 9*7 = 63, 9*8 = 72, 9*9 = 81, do~while문 do~while문: 일단 한번은 문장들을 수행하고 그 다음에 조건식을 검사해서 반복문을 결정. 조건의 참/거짓 여부에 관계없이 적어도 한번은 수행됨. do { //실행되는 부분 } while(조건식); do~while문을 이용하여 구구단 만들기. public class Do_While { public static void main(String[] args) { // do~while문을 이용하여 구구단 만들기 int row = 1; int column = 2; do { row++; do { System.out.printf(\"%3d*%d = %2d,\", row, column, row * column); column++; } while (column &lt; 10); column = 2; System.out.printf(\"\\n\"); } while (row &lt; 10); } } 2*2 = 4, 2*3 = 6, 2*4 = 8, 2*5 = 10, 2*6 = 12, 2*7 = 14, 2*8 = 16, 2*9 = 18, 3*2 = 6, 3*3 = 9, 3*4 = 12, 3*5 = 15, 3*6 = 18, 3*7 = 21, 3*8 = 24, 3*9 = 27, 4*2 = 8, 4*3 = 12, 4*4 = 16, 4*5 = 20, 4*6 = 24, 4*7 = 28, 4*8 = 32, 4*9 = 36, 5*2 = 10, 5*3 = 15, 5*4 = 20, 5*5 = 25, 5*6 = 30, 5*7 = 35, 5*8 = 40, 5*9 = 45, 6*2 = 12, 6*3 = 18, 6*4 = 24, 6*5 = 30, 6*6 = 36, 6*7 = 42, 6*8 = 48, 6*9 = 54, 7*2 = 14, 7*3 = 21, 7*4 = 28, 7*5 = 35, 7*6 = 42, 7*7 = 49, 7*8 = 56, 7*9 = 63, 8*2 = 16, 8*3 = 24, 8*4 = 32, 8*5 = 40, 8*6 = 48, 8*7 = 56, 8*8 = 64, 8*9 = 72, 9*2 = 18, 9*3 = 27, 9*4 = 36, 9*5 = 45, 9*6 = 54, 9*7 = 63, 9*8 = 72, 9*9 = 81, 10*2 = 20, 10*3 = 30, 10*4 = 40, 10*5 = 50, 10*6 = 60, 10*7 = 70, 10*8 = 80, 10*9 = 90, break, continue문 break문: 반복을 멈추게 함. 반복문을 벗어나서 반복문 다음의 코드를 수행하도록 함. continue문: 현재의 반복을 뛰어넘고 반복을 진행시킴. break, continue문을 이용한 랜덤 숫자 맞추기 게임. import java.util.Scanner; public class RandomNumberGame { public static void main(String[] args) { // 숫자 맞추기 게임. // 랜덤한 숫자(random) 생성. 랜덤 : 72; 몰?루 // ㄴ Math.random() : 0~1 구간에서 소수점의 난수를 생성. // 숫자를 입력하세요 : Scanner input // input이 random보다 작다, 크다, 같다 // ㄴ 같을 경우, n번만에 맞췄습니다. // ㄴ 다시 진행 하시겠습니까?((Y/N)) // ㄴ Y는 continue, N는 break; // 최소값, 최대값보다 크거나 작을 때 continue 등 그냥 추가. Scanner input = new Scanner(System.in); int num = 0; // user가 입력할 숫자. int cnt = 0; // 카운트 char yn; // 게임 재진행 여부 // 사용자가 범위 지정하기 int umin = 0; int umax = 0; System.out.printf(\"게임에서 사용할 최소 범위를 지정해주세요\\n\"); umin = input.nextInt(); System.out.printf(\"게임에서 사용할 최대 범위를 지정해주세요\\n\"); umax = input.nextInt(); int min = umin; // 지정된 최소값 int max = umax; // 지정된 최대값 int random = (int) (Math.random() * 100000); // 랜덤하게 생성할 숫자. (0~많이) System.out.printf(\"랜덤 숫자 생성중\\n\"); // while문 돌리는 동안 시간걸림 while (true) { if ((umin &gt; random) || (umax &lt; random)) { // 사용자가 지정한 값을 벗어나면. random = (int) (Math.random() * 1000000000); // 다시 값 정하기 continue; // 조건물 탈출 } else { // 값 안이면 break; } } // System.out.printf(\"게임을 시작합니다.\\n\"); // System.out.println(random); // random 테스트 // System.out.printf(\"숫자 테스트%d %d \\n\", umin, umax); // 숫자 테스트용 while (true) { System.out.printf(\"숫자를 입력하세요.\\n(%d~%d)\\n\", min, max); num = input.nextInt(); /* * if(min&gt;num) { // 최소값보다 입력한 값이 작을 때 * System.out.printf(\"입력한 숫자가 최소값보다 작습니다. 다시 입력해주세요.\\n\\n\"); continue; } * if(max&lt;num) { // 최대값보다 입력한 값이 클 때 * System.out.printf(\"입력한 숫자가 최대값보다 큽니다. 다시 입력해주세요.\\n\\n\"); continue; } */ if (random != num) { // 숫자가 다를 때. if (random &gt; num) { // 랜덤이 더 클 때 System.out.printf(\"입력한 숫자가 더 작습니다.\\n\"); min = num; min = min + 1; cnt++; continue; } else if (random &lt; num) { // 랜덤이 더 작을 때 System.out.printf(\"입력한 숫자가 더 큽니다.\\n\"); max = num; max = max - 1; cnt++; continue; } } else { System.out.printf(\"정답입니다! %d회에 맞췄습니다.\\n\", cnt); System.out.printf(\"게임을 다시 진행하시겠습니까?(Y/N)\\n\"); yn = input.next().charAt(0); // char n글자 따기 : .next().charAt(n); if ((yn == 'Y') || (yn == 'y')) { random = (int) (Math.random() * 90 + 10); // 다시 랜덤하게. cnt = 0; // 카운트 초기화 min = 10; // 최소값 초기화 max = 99; // 최대값 초기화 System.out.printf(\"게임을 다시 진행합니다...\\n\\n\\n\"); System.out.printf(\"게임을 시작합니다.\\n\"); continue; } else if ((yn == 'N') || (yn == 'n')) { // random = (int)(Math.random()*90+10); // 다시 랜덤하게. 굳이? // cnt = 0; // 카운트 초기화 System.out.printf(\"게임이 종료됩니다...\\n\"); break; } } } // while 종료 } } 게임에서 사용할 최소 범위를 지정해주세요 1 게임에서 사용할 최대 범위를 지정해주세요 10 랜덤 숫자 생성중 숫자를 입력하세요. (1~10) 5 입력한 숫자가 더 큽니다. 숫자를 입력하세요. (1~4) 2 정답입니다! 1회에 맞췄습니다. 게임을 다시 진행하시겠습니까?(Y/N) n 게임이 종료됩니다...",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/26/3.-%EC%A0%9C%EC%96%B4%EB%AC%B8.html"
  },{
    "title": "2. 연산자",
    "text": "연산자의 종류와 우선순위 연산자란? 특정한 연산을 수행하기 위해 사용하는 기호. 종류 연산자 설명 산술 연산자 + - * / % 사칙연산 및 나머지 연산 단항 연산자 - 부호 연산자 ^^ ! 논리 부정 연산자 ^^ ++ -- 증감 연산자 비교 연산자 &gt; &lt; &gt;= &lt;= == !=&gt; 양 변을 비교하는 연산 논리 연산자 &amp;&amp; || ^ AND, OR, XOR 연산 쉬프트 연산자 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 비트를 이동하는 연산 기타 연산자 (조건)? 참:거짓 삼항 연산자 ^^ = += -= *= 대입 연산자 산술 연산자 연산자 의미 사용방법 설명 + 더하기 c = a + b 변수 c에 a와 b의 더한 결과 값을 대입 - 빼기 c = a - b 변수 c에 a에서 b를 뺀 결과 값을 대입 * 곱하기 c = a * b 변수 c에 a와 b를 곱한 결과 값을 대입 / 나누기 c = a / b 변수 c에 a를 b로 나눈 결과 값을 대입 % 나머지 c = a % b 변수 c에 a를 b로 나눈 나머지를 대입 public class Operator { public static void main(String[] args) { int a = 10; int b = 3; System.out.println(a + b); System.out.println(a - b); System.out.println(a * b); System.out.println(a / b); System.out.println(a % b); } } 13 7 30 3 1 단항 연산자 단항 연산자란? 항이 하나인 연산자. 연산자 의미 사용방법 설명 + , - 부호연산자 -a 변수 a의 부호를 바꿈. ! 부정연산자 !a 논리 부정 연산자는 참을 거짓으로, 거짓을 참으로 바꾸는 연산자. ++ 증가연산자 ++a; 또는 a++; 변수 a에 1을 더하여 a에 기억시킨다. -- 감소연산자 --a; 또는 a--; 변수 a에 1을 뺀후 a에 기억시킨다. 부호 연산자(+, -) public class Sign_operator { public static void main(String[] args) { int a = -1; int b = 2; System.out.println(a); System.out.println(-b); } } -1 -2 논리 부정 연산자(!) public class Logic_operator { public static void main(String[] args) { boolean a = true; boolean b = false; boolean c = !b; System.out.println(a); System.out.println(!a); System.out.println(b); System.out.println(c); } } true false false true 증감 연산자(++, –) ++변수명 : 변수가 사용되기 전에 값이 증가된다. 변수명++ : 변수가 사용된 후에 값이 증가된다. --변수명 : 변수가 사용되기 전에 값이 감소된다. 변수명-- : 변수가 사용된 후에 값이 감소된다. public class operator_ch3 { public static void main(String[] args) { int a = 1; System.out.println(a); a++; System.out.println(a); System.out.println(++a); System.out.println(a++); System.out.println(a); } } 1 2 3 3 4 비교 연산자(equals) 비교 연산자란? 양변을 비교하여 맞으면 참(true), 다르면 거짓(false)를 반환하는 연산자. 종류 연산자 연산자 사용방법 설명 같다 == a == b a와 b가 같으면 참 작다 &lt; a &lt; b a가 b보다 작으면 참 크다 &gt; a &gt; b a가 b볻 ㅏ크면 참 작거나 같다 &lt;= a &lt;= b a가 b보다 작거나 같으면 참 크거나 같다 &gt;= a &gt;= b a가 b보다 크거나 같으면 참 같지 않다 != a != b a와 b가 같지 않으면 참 대소비교 연산자(&lt;. &gt;, &lt;=, &gt;=) public class inequality_sign_operator { public static void main(String[] args) { int a = 10; int b = 20; int c = 30; System.out.println(a &lt; b); System.out.println(a &gt; b); System.out.println(a + b &lt;= c); System.out.println(a + b &gt;= c); } } true false true true 등가비교 연산자(==, !=) public class Equality_sign_operation { public static void main(String[] args) { double a = 3.14; double b = 5.14; System.out.println(a == b); System.out.println(a != b); String c1 = \"Hello JAVA!\"; System.out.println(c1.equals(\"Hello java!\")); System.out.println(c1.equals(\"Hello JAVA!\")); } } false true false true 논리 연산자(&amp;&amp;, ||, ^) 논리 연산자란? 여러 가지 조건을 동시에 검사할 때 사용하는 연산자, 두 항의 값이 boolean 값일 경우에 사용. 종류 연산자 사용예 설명 AND &amp;&amp; a &amp;&amp; b a가 참이고 bㅇ면 참이 된다. OR || a || b a또는 b중 하나라도 참이면 참이 된다. NOT ! !a a가 참이면 거짓이 되고, 거짓이면 참이 된다. public class Logic_operator2 { public static void main(String[] args) { int a = 10; System.out.println(5 &lt; a &amp;&amp; a &lt; 15); System.out.println((5 &lt; a &amp;&amp; a &lt; 15) &amp;&amp; a % 2 == 0); a = 4; System.out.println((5 &lt; a &amp;&amp; a &lt; 15) &amp;&amp; a % 2 == 0); System.out.println((5 &lt; a &amp;&amp; a &lt; 15) || a % 2 == 0); } } true true false true 비트 연산자 비트 연산자란? 개발자가 직접 비트를 조작할 수 있는 연산자. 연산하는 수를 이진수로 표현했을 때 규칙에 따라 알맞은 결과를 반환함. 종류 연산자 사용방법 설명 비트 AND &amp; a &amp; b 변수 a와 b의 비트 단위의 AND 비트 OR | a | b 변수 a와 변수 b의 비트 단우의 OR 비트 XOR ^ a ^ b 변수 a와 변수 b의 비트단위의 XOR 비트 NOT ~ ~a 변수 a의 단위의 부정 public class xor_practice { public static void main(String[] args) { int a = 15; int b = 5; System.out.println(a | b); System.out.println(a &amp; b); System.out.println(a ^ b); System.out.println(a &gt;&gt; 2); System.out.println(b &lt;&lt; 4); } } 15 5 10 3 80 기타 연산자 삼항 연산자 삼항 연산자란? 항이 세 개인 연산자. 조건식의 참/거짓 여부에 따라서 각각 다른 결과를 반환. 조건?항목1:항목2 조건 : 참과 거짓으로 구분할 수 있는 비교 연산, 논리 연산. 항목1 : 조건이 참인 경우 실행할 연산이나 함수. 항목2 : 조건이 거짓인 경우 실행할 연산이나 함수. public class Three_operator { public static void main(String[] args) { int age = 17; System.out.println(age &gt; 19 ? \"성인입니다.\" : \"청소년입니다.\"); } } 청소년입니다. 대입 연산자 대임 연산자란? 값을 할당하는 데 쓰이는 연산자로서, 자주 사용하는 연산을 간결하게 코딩할 수 있도록 만들어진 연산자. 연산자 예 설명 풀어쓴 형식 = a = 1 변수 a에 1을 기억 a = 1 +=(더하기) a += 2 변수에 a에 2를 더하여 다시 a에 기억 a = a + 2 -=(빼기) a -= 4 변수 a에서 4fmf 뺀 후 다시 a에 기억 a = a - 4 *=(곱하기) a *= 7 변수 a에 7을 곱한 후 다시 a에 기억 a = a * 7 /=(나누기 a /= 3 변수 a를 3으로 나눈 몫을 다시 a에 기억 a = a / 3 %=(나머지) a % 5 변수 a를 5로 나눈 나머지를 a에 기억 a = a % 5 public class Assign_operator { public static void main(String[] args) { // TODO Auto-generated method stub int a = 3; int b = 5; b = a; System.out.println(b); a += 1; System.out.println(a); a /= 2; System.out.println(a); a *= a; System.out.println(a); } } 3 4 2 4 instanceof instanceof연산자란? 객체 타입을 확인하는 연산자. 주로 조건문에서 사용되며 instanceof의 왼쪽에는 참조변수를 오른쪽에는 클래스명을 두고 연산함. 연산의 결과로 true 또는 false를 반환함. 결과 값이 true일 경우 해당 참조변수는 검사한 타입으로 형변환이 가능하는 것을 뜻함. class A { } class B extends A { } public class hello { public static void main(String[] args) { A a = new A(); B b = new B(); System.out.println(\"a instanceof A: \" + (a instanceof A)); System.out.println(\"b instanceof A: \" + (a instanceof A)); System.out.println(\"a instanceof B: \" + (a instanceof B)); System.out.println(\"b instanceof B: \" + (b instanceof B)); } } a instanceof A: true b instanceof A: true a instanceof B: false b instanceof B: true",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/25/2.-%EC%97%B0%EC%82%B0%EC%9E%90.html"
  },{
    "title": "1. 변수와 상수",
    "text": "변수란? 프로그램의 처리 과정에서 데이터를 담아둘 수 있는 메모리의 공간. 하나의 변수에는 하나의 값만 저장할 수 있고 이 값을 변경할 수 있기때문에 변수라고 부름. 데이터 타입 정수형 데이터 타입 자료형 바이트 비트 저장 가능한 값의 범위 byte 1 8 -128 ~ 127 short 2 16 -32,768 ~ 32,767 int 4 32 -2,147,483,648 ~ 2,147,483,647 long 8 64 -263 ~ 263-1 실수형 데이터 타입 자료형 바이트 비트 저장 가능한 값의 범위 오차 범위 float 4 32 1.4 x 10-45 ~ 3.4 x 1038 소수 이하 6자리 double 8 64 4.9 x 10-324 ~ 1.8 x 10308 소수 이하 15자리 문자형 데이터 타입 자료형 바이트 비트 저장 가능한 값의 범위 char 2 15 0 ~ 216-1(유니코드 0 ~ 65535) 논리형 데이터 타입 boolean : true(1), false : (0) 형 변환 형변환이란 말 그대로 변수나 상쉬으 데이터 타입을 다른 타입으로 바꾸는 것을 의미함. 명시적 형변환 : 프로그래머가 데이터 형을 강제로 변환. (변환하고자하는 타입) 변수명; public class DataType { public static void main(String[] args) { byte a = 127; int b = a; // 자동변환 System.out.println(b); float c = b; // 자동변환 System.out.println(c); int d = 263; System.out.println(d); byte e = (byte) d; // 명시적 형변환 System.out.println(e); } } 127 127.0 263 7 상수의 선언 상수 : 프로그램 실행 중에 변경 할 수 없는 고정된 값. public class Prca { public static void main(String[] args) { int a = 3; a = 4; final double PI = 3.14; PI = 3.15; // 에러 발생 } } 변수 a는 3에서 4로 값이 변경할 수 있지만 final이 붙은 PI는 상수이므로 값을 변경하면 에러가 발생함.",
    "tags": "JAVA",
    "url": "/jekyll-theme-yat/java/2022/10/25/1.-%EB%B3%80%EC%88%98%EC%99%80-%EC%83%81%EC%88%98.html"
  },{
    "title": "URL Shorter Project",
    "text": "URL Shorter Project 단축 주소 생성 Java 프로젝트입니다. Java를 공부하던 중 php 언어로 된 단축 주소 생성 웹을 Java로 만들어보자는 생각이 들어 만들었습니다. php 출처 : PHP) 단축 URL 서비스 구축하기 코드 URL Entity package shorter.Entity; import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import javax.persistence.*; @Entity @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class Url { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String addr; private String shorter; private boolean customCheck; private String timestampt; private String lastUsed; } Shorter API package shorter.DAO; import org.springframework.stereotype.Component; @Component public class Shorter { // 단축 주소 생성 public String makeShorter(int id) { id += 10000000; return base_convert(Integer.toString(id), 10, 36); } // n진수로 변경하는 함수 public static String base_convert(final String inputValue, final int fromBase, final int toBase) { if (fromBase &lt; 2 || fromBase &gt; 36 || toBase &lt; 2 || toBase &gt; 36) { return null; } String ret = null; try { ret = Integer.toString(Integer.parseInt(inputValue, fromBase), toBase); } catch (Exception ex) { ex.printStackTrace(); } return ret; } } Controller package shorter; import shorter.DAO.*; import shorter.Entity.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import java.util.List; @Controller public class URLShorterController { final URLShorterDAO dao; @Autowired Shorter st; @Autowired public URLShorterController(URLShorterDAO dao) { this.dao = dao; } final String http = \"http://localhost/\"; @GetMapping(\"\") public String index() { return \"/index\"; } @PostMapping(\"\") public String adddata(@RequestParam String input, @RequestParam String custom, Model m) throws Exception { Url u = new Url(); Url r = null; Url l = null; String randum = null; try { if (input.equals(\"\")) { // 아무것도 입력 안되어 있으면, // 에러 출력 : URL을 입력해주세요. m.addAttribute(\"error\", \"2\"); return \"/index\"; } // 데이터 등록 시작 if (custom.equals(\"\")) { // 커스텀 단축이 아니면, // 입력한 주소가 커스텀 주소가 아니고, 데이터베이스에 있다면, l = dao.getDataToInput(input); if (l != null) { // 데이터 추가하지 말고 등록된 값 뿌려주자. m.addAttribute(\"shorterurl\", http + l.getShorter()); return \"/index\"; } // php에서 사용하던 방식 그대로 사용. // 생성 u.setAddr(input); u.setCustomCheck(false); dao.addShorter(u); // 그리고 생성된 id값으로 Shorter 업데이트 u.setShorter(st.makeShorter(u.getId())); dao.addShorter(u); } else { // 커스텀 단축이면 // 데이터 조회 r = dao.getDataToShorter(custom); // 동일한 값이 db에 있다면 if (r != null) { // 에러 출력 : 이미 존재하는 커스텀 단축 주소입니다. m.addAttribute(\"error\", \"0\"); return \"/index\"; } u.setAddr(input); u.setShorter(custom); u.setCustomCheck(true); //데이터 저장. dao.addShorter(u); } } catch (Exception e) { // 에러 출력 : 예기치 않는 오류가 발생했습니다. m.addAttribute(\"error\", \"3\"); e.printStackTrace(); return \"/index\"; } m.addAttribute(\"shorterurl\", http + u.getShorter()); return \"/index\"; } @GetMapping(\"/{shorter}\") public String gotoadr(@PathVariable String shorter, Model m) throws Exception { try { // 입력받은 단축 주소로 데이터 검색. Url u = dao.getDataToShorter(shorter); // 데이터가 있다면, if (u != null) { m.addAttribute(\"addr\", u.getAddr()); //데이터 업데이트 : 마지막 사용 시간 dao.update(u); return \"/Control\"; } else { // 데이터가 없다면. // 에러 출력 : 존재하지 않는 단축 주소입니다. m.addAttribute(\"error\", \"1\"); return \"/index\"; } } catch (Exception e) { // 에러 출력 : 예기치 않는 오류가 발생했습니다. m.addAttribute(\"error\", \"3\"); e.printStackTrace(); return \"/index\"; } } } index.jsp &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;html&gt; &lt;head&gt; &lt;!-- Google tag (gtag.js) --&gt; &lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=G-1N3FJ1ETYL\"&gt;&lt;/script&gt; &lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-1N3FJ1ETYL'); &lt;/script&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;meta name=\"author\" content=\"url shortener\"&gt; &lt;meta property=\"og:type\" content=\"website\"&gt; &lt;meta property=\"og:title\" content=\"단축 주소 생성\"&gt; &lt;meta property=\"og:url\" content=\"ipi.pw\"&gt; &lt;meta property=\"og:description\" content=\"단축 주소 생성 웹페이지입니다.\"&gt; &lt;meta property=\"og:image\" content=\"test.png\"&gt; &lt;title&gt;단축 주소 생성 웹&lt;/title&gt; &lt;link href=\"http://localhost/css/main.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://code.jquery.com/jquery-3.6.1.min.js\" integrity=\"sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"/js/loading.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function loading() { $('#loading').show(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"loading\"&gt;&lt;img id=\"loading-image\" src=\"/images/loading.gif\" alt=\"Loading...\" /&gt;&lt;/div&gt; &lt;br&gt; &lt;center&gt; &lt;h1&gt;단축 URL 생성&lt;/h1&gt; &lt;% String shorterurl = (String) request.getAttribute(\"shorterurl\"); if (shorterurl != null) { %&gt; &lt;p class=\"success\"&gt;&lt;a id =\"a\" href=\"&lt;%=shorterurl%&gt;\"&gt;&lt;%=shorterurl%&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3&gt;&lt;div id=\"copyok\" class=\"copyok\" style=\"display:none\"&gt;복사완료&lt;/div&gt;&lt;/h3&gt; &lt;input type=\"submit\" id=\"btn_div_copy\" value=\"복사\" class=\"submit_copy\"&gt; &lt;% } String error = (String) request.getAttribute(\"error\"); if (error != null) { if (error.equals(\"0\")) { %&gt; &lt;p class=\"alert\"&gt;이미 존재하는 커스텀 주소입니다.&lt;/p&gt; &lt;% } else if (error.equals(\"1\")) { %&gt; &lt;p class=\"alert\"&gt;존재하지 않는 단축 주소입니다.&lt;/p&gt; &lt;% } else if (error.equals(\"2\")) { %&gt; &lt;p class=\"alert\"&gt;URL을 입력해주세요.&lt;/p&gt; &lt;% } else if (error.equals(\"3\")) { %&gt; &lt;p class=\"alert\"&gt;예기치 않는 오류가 발생했습니다.&lt;/p&gt; &lt;% } } %&gt; &lt;form action=\"/\" method=\"post\" onsubmit=\"return loading()\"&gt; &lt;div class=\"section group\"&gt; &lt;div class=\"col span_3_of_3\"&gt; &lt;input type=\"url\" id=\"input\" name=\"input\" autocomplete=\"off\" name=\"url\" class=\"input\" placeholder=\"Ex)https://www.naver.com\" required autofocus&gt; &lt;/div&gt; &lt;div class=\"col span_1_of_3\"&gt; &lt;input type=\"text\" id=\"custom\" name=\"custom\" autocomplete=\"off\" name=\"custom\" class=\"input_custom\" placeholder=\"커스텀 주소\" readonly&gt; &lt;/div&gt; &lt;div class=\"col span_2_of_3\"&gt; &lt;div class=\"onoffswitch\"&gt; &lt;input type=\"checkbox\" name=\"onoffswitch\" class=\"onoffswitch-checkbox\" id=\"myonoffswitch\" onclick=\"toggle()\"&gt; &lt;label class=\"onoffswitch-label\" for=\"myonoffswitch\"&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"Generate\" class=\"submit\"&gt; &lt;/form&gt; &lt;script&gt; function toggle() { if (document.getElementById('myonoffswitch').checked) { document.getElementById('custom').placeholder = '커스텀 주소를 입력하세요' document.getElementById('custom').readOnly = false document.getElementById('custom').focus() } else { document.getElementById('custom').value = '' document.getElementById('custom').placeholder = '커스텀 주소' document.getElementById('custom').readOnly = true document.getElementById('custom').blur() document.getElementById('input').focus() } } document.getElementById(\"btn_div_copy\").onclick = function () { // a 내부 텍스트 취득 const valOfDIV = document.getElementById(\"a\").innerText; // textarea 생성 const textArea = document.createElement(\"textarea\"); // textarea 추가 document.body.appendChild(textArea); // textara의 value값으로 div내부 텍스트값 설정 textArea.value = valOfDIV; // textarea 선택 및 복사 textArea.select(); document.execCommand(\"copy\"); //alert(\"복사완료\") document.getElementById(\"copyok\").style.display = \"block\"; // textarea 제거 document.body.removeChild(textArea); } &lt;/script&gt; &lt;/center&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;script src=\"//developers.kakao.com/sdk/js/kakao.min.js\"&gt;&lt;/script&gt; &lt;script&gt; Kakao.init(\"deb52fd0e85dcc27c791af5b139b6c29\"); function sendLink() { Kakao.Link.sendCustom({ templateId: 19117, templateArgs: { title: \"URL Shorter Project\", description: \"&lt;h1 id=\"url-shorter-project\"&gt;URL Shorter Project&lt;/h1&gt; \", url: \"/portfolio/2022/10/20/Shorther-URL.html\", }, }); } &lt;/script&gt; &lt;h2&gt; &lt;a id=\"kakao-link-btn\" href=\"javascript:sendLink()\"&gt; &lt;img src=\"//developers.kakao.com/assets/img/about/logos/kakaolink/kakaolink_btn_medium.png\" /&gt;&lt;/img&gt; &lt;/a&gt; &lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; control.jsp &lt;% String addr = (String) request.getAttribute(\"addr\"); response.sendRedirect(addr); %&gt; 프로젝트 git 주소 : github.com",
    "tags": "URL Shorter portfolio JAVA",
    "url": "/jekyll-theme-yat/portfolio/2022/10/20/Shorther-URL.html"
  },{
    "title": "Lib Project Portfolio",
    "text": "학원에서 팀 프로젝트로 도서관 웹을 만들었습니다. (도서관이라고 하기 기능이 이상하지만 아무튼 도서관입니다.) 처음으로 만든 포트폴리오라 틀리거나 잘못된 부분이 많습니다. 차후 수정해 나갈 예정입니다. 노션 바로가기 : Lib Project",
    "tags": "Lib Project portfolio JAVA",
    "url": "/jekyll-theme-yat/portfolio/2022/10/20/Lib-Project-Portfolio.html"
  },{
    "title": "테스트 게시글",
    "text": "테스트 게시글 입니다. Boxes You can add notification, warning and error boxes like this: Notification Note: This is a notification box. Warning Warning: This is a warning box. Error Error: This is an error box.",
    "tags": "test",
    "url": "/jekyll-theme-yat/test/2022/10/19/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B2%8C%EC%8B%9C%EA%B8%80.html"
  }]};
